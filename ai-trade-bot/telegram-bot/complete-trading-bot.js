const TelegramBot = require('node-telegram-bot-api');
const axios = require('axios');
const crypto = require('crypto');
require('dotenv').config();

// Configuraci√≥n del bot
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || 'YOUR_BOT_TOKEN';
const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';
const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'your-32-char-secret-key-here!';

// Crear instancia del bot
const bot = new TelegramBot(BOT_TOKEN, { polling: true });

// Almacenar datos de usuarios (en producci√≥n usar base de datos)
const userSessions = new Map();
const userWallets = new Map();
const userPositions = new Map();

// Funci√≥n de encriptaci√≥n simple
function encrypt(text) {
  const cipher = crypto.createCipher('aes-256-cbc', ENCRYPTION_KEY);
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return encrypted;
}

function decrypt(encryptedText) {
  const decipher = crypto.createDecipher('aes-256-cbc', ENCRYPTION_KEY);
  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  return decrypted;
}

// Funci√≥n para generar wallet Stellar
function generateStellarWallet() {
  const StellarSdk = require('stellar-sdk');
  const keypair = StellarSdk.Keypair.random();
  return {
    publicKey: keypair.publicKey(),
    secretKey: keypair.secret()
  };
}

// Funci√≥n para obtener precio de XLM
async function getXlmPrice() {
  try {
    const response = await axios.get(`${API_BASE_URL}/api/soroswap/price`);
    return response.data.data?.price_usd || 0;
  } catch (error) {
    console.error('Error obteniendo precio:', error);
    return 0.15; // Precio de fallback
  }
}

// Funci√≥n para obtener cotizaci√≥n de swap
async function getSwapQuote(amount) {
  try {
    const response = await axios.post(`${API_BASE_URL}/api/soroswap/quote`, {
      amount: amount
    });
    return response.data;
  } catch (error) {
    console.error('Error obteniendo cotizaci√≥n:', error);
    return null;
  }
}

// Funci√≥n para ejecutar swap real
async function executeSwap(publicKey, amount, quote) {
  try {
    const response = await axios.post(`${API_BASE_URL}/api/soroswap/execute`, {
      sourceAccount: publicKey,
      quote: quote.data.quote,
      network: 'testnet'
    });
    return response.data;
  } catch (error) {
    console.error('Error ejecutando swap:', error);
    return null;
  }
}

// Funci√≥n para abrir posici√≥n de trading
async function openPosition(publicKey, amount, leverage, type) {
  try {
    const response = await axios.post(`${API_BASE_URL}/api/contract/real-operations`, {
      action: 'open_position',
      publicKey: publicKey,
      amount: amount,
      leverage: leverage,
      type: type
    });
    return response.data;
  } catch (error) {
    console.error('Error abriendo posici√≥n:', error);
    return null;
  }
}

// Funci√≥n para cerrar posici√≥n
async function closePosition(publicKey, positionId) {
  try {
    const response = await axios.post(`${API_BASE_URL}/api/contract/real-operations`, {
      action: 'close_position',
      publicKey: publicKey,
      positionId: positionId
    });
    return response.data;
  } catch (error) {
    console.error('Error cerrando posici√≥n:', error);
    return null;
  }
}

// Comando /start
bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;
  const username = msg.from.username || msg.from.first_name;
  
  const welcomeMessage = `
ü§ñ **¬°Hola ${username}!** 

Soy tu bot de trading completo en Stellar. Puedo ayudarte a:

üí∞ **Trading de Perpetuos**
‚Ä¢ Abrir posiciones long/short
‚Ä¢ Cerrar posiciones autom√°ticamente
‚Ä¢ Calcular PnL en tiempo real

üîÑ **Swaps Autom√°ticos**
‚Ä¢ XLM ‚Üî USDC instant√°neos
‚Ä¢ Mejores tasas con Soroswap
‚Ä¢ Confirmaci√≥n en segundos

üìä **Gesti√≥n Completa**
‚Ä¢ Crear wallet segura
‚Ä¢ Ver balances en tiempo real
‚Ä¢ Historial de transacciones

**Comandos principales:**
/wallet - Crear/gestionar wallet
/swap - Hacer swap XLM‚ÜíUSDC
/trade - Abrir posici√≥n de trading
/positions - Ver posiciones activas
/balance - Ver balance actual
/price - Precio de XLM

¬øEmpezamos? üöÄ
  `;
  
  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [
          { text: 'üîë Crear Wallet', callback_data: 'create_wallet' },
          { text: 'üí∞ Ver Balance', callback_data: 'view_balance' }
        ],
        [
          { text: 'üìä Ver Precios', callback_data: 'view_prices' },
          { text: 'üîÑ Hacer Swap', callback_data: 'make_swap' }
        ],
        [
          { text: 'üìà Trading', callback_data: 'trading_menu' },
          { text: 'üìã Mis Posiciones', callback_data: 'view_positions' }
        ]
      ]
    }
  };
  
  bot.sendMessage(chatId, welcomeMessage, { parse_mode: 'Markdown', ...keyboard });
});

// Comando /wallet
bot.onText(/\/wallet/, (msg) => {
  const chatId = msg.chat.id;
  
  if (userWallets.has(chatId)) {
    const wallet = userWallets.get(chatId);
    const walletMessage = `
üîë **Tu Wallet Stellar**

**Clave P√∫blica:**
\`${wallet.publicKey}\`

**Estado:** ‚úÖ Activa
**Red:** Stellar Testnet
**Creada:** ${new Date(wallet.createdAt).toLocaleString()}

**Comandos:**
/balance - Ver balance
/export - Exportar wallet
/import - Importar wallet existente
    `;
    
    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üí∞ Ver Balance', callback_data: 'view_balance' },
            { text: 'üì§ Exportar', callback_data: 'export_wallet' }
          ],
          [
            { text: 'üîÑ Importar', callback_data: 'import_wallet' },
            { text: 'üóëÔ∏è Eliminar', callback_data: 'delete_wallet' }
          ]
        ]
      }
    };
    
    bot.sendMessage(chatId, walletMessage, { parse_mode: 'Markdown', ...keyboard });
  } else {
    const createMessage = `
üîë **Crear Nueva Wallet**

No tienes una wallet creada. ¬øQuieres crear una nueva?

**Caracter√≠sticas:**
‚Ä¢ Generaci√≥n segura de claves
‚Ä¢ Encriptaci√≥n local
‚Ä¢ Compatible con Stellar
‚Ä¢ Fondeo autom√°tico en testnet

**¬øCrear wallet ahora?**
    `;
    
    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '‚úÖ S√≠, Crear', callback_data: 'create_wallet' },
            { text: '‚ùå Cancelar', callback_data: 'cancel' }
          ]
        ]
      }
    };
    
    bot.sendMessage(chatId, createMessage, { parse_mode: 'Markdown', ...keyboard });
  }
});

// Comando /swap
bot.onText(/\/swap (.+) XLM/, async (msg, match) => {
  const chatId = msg.chat.id;
  const amount = parseFloat(match[1]);
  
  if (!userWallets.has(chatId)) {
    bot.sendMessage(chatId, '‚ùå Primero debes crear una wallet con /wallet');
    return;
  }
  
  if (isNaN(amount) || amount <= 0) {
    bot.sendMessage(chatId, '‚ùå Cantidad inv√°lida. Usa: /swap 5 XLM');
    return;
  }
  
  try {
    const wallet = userWallets.get(chatId);
    
    // Mostrar mensaje de inicio
    const startMessage = `
üîÑ **Iniciando Swap**
‚Ä¢ **Cantidad:** ${amount} XLM
‚Ä¢ **Destino:** USDC
‚Ä¢ **Wallet:** ${wallet.publicKey.slice(0, 8)}...
‚Ä¢ **Estado:** Obteniendo cotizaci√≥n...
    `;
    
    await bot.sendMessage(chatId, startMessage, { parse_mode: 'Markdown' });
    
    // Obtener cotizaci√≥n
    const quote = await getSwapQuote(amount);
    
    if (!quote || !quote.success) {
      bot.sendMessage(chatId, '‚ùå Error obteniendo cotizaci√≥n. Intenta de nuevo.');
      return;
    }
    
    const outputAmount = (parseInt(quote.data.quote.amountOut) / 1_000_000).toFixed(6);
    
    // Mostrar cotizaci√≥n y pedir confirmaci√≥n
    const quoteMessage = `
üìä **Cotizaci√≥n Obtenida**
‚Ä¢ **Entrada:** ${amount} XLM
‚Ä¢ **Salida:** ~${outputAmount} USDC
‚Ä¢ **Protocolo:** ${quote.data.quote.platform}
‚Ä¢ **Red:** ${quote.data.network}

**¬øConfirmas el swap?**
    `;
    
    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: '‚úÖ Confirmar Swap', callback_data: `confirm_swap_${amount}` },
            { text: '‚ùå Cancelar', callback_data: 'cancel' }
          ]
        ]
      }
    };
    
    await bot.sendMessage(chatId, quoteMessage, { parse_mode: 'Markdown', ...keyboard });
    
    // Guardar datos del swap
    userSessions.set(chatId, {
      type: 'swap',
      amount,
      quote,
      status: 'waiting_confirmation'
    });
    
  } catch (error) {
    console.error('Error en swap:', error);
    bot.sendMessage(chatId, '‚ùå Error procesando el swap. Intenta de nuevo.');
  }
});

// Comando /trade
bot.onText(/\/trade/, (msg) => {
  const chatId = msg.chat.id;
  
  if (!userWallets.has(chatId)) {
    bot.sendMessage(chatId, '‚ùå Primero debes crear una wallet con /wallet');
    return;
  }
  
  const tradeMessage = `
üìà **Trading de Perpetuos**

**Configuraci√≥n de Posici√≥n:**
‚Ä¢ **Cantidad:** 100 XLM (por defecto)
‚Ä¢ **Leverage:** 2x (por defecto)
‚Ä¢ **Tipo:** Long (por defecto)

**¬øQuieres personalizar la configuraci√≥n?**
  `;
  
  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [
          { text: 'üìà Long 2x', callback_data: 'trade_long_2x' },
          { text: 'üìâ Short 2x', callback_data: 'trade_short_2x' }
        ],
        [
          { text: 'üìà Long 5x', callback_data: 'trade_long_5x' },
          { text: 'üìâ Short 5x', callback_data: 'trade_short_5x' }
        ],
        [
          { text: '‚öôÔ∏è Personalizar', callback_data: 'custom_trade' },
          { text: '‚ùå Cancelar', callback_data: 'cancel' }
        ]
      ]
    }
  };
  
  bot.sendMessage(chatId, tradeMessage, { parse_mode: 'Markdown', ...keyboard });
});

// Comando /positions
bot.onText(/\/positions/, (msg) => {
  const chatId = msg.chat.id;
  
  if (!userPositions.has(chatId) || userPositions.get(chatId).length === 0) {
    bot.sendMessage(chatId, '‚ùå No tienes posiciones activas.\n\nUsa /trade para abrir una nueva posici√≥n.');
    return;
  }
  
  const positions = userPositions.get(chatId);
  let positionsMessage = 'üìä **Tus Posiciones Activas**\n\n';
  
  positions.forEach((position, index) => {
    const pnl = position.pnl >= 0 ? `+$${position.pnl.toFixed(2)}` : `-$${Math.abs(position.pnl).toFixed(2)}`;
    const pnlEmoji = position.pnl >= 0 ? 'üìà' : 'üìâ';
    
    positionsMessage += `**Posici√≥n #${index + 1}:**\n`;
    positionsMessage += `‚Ä¢ Tipo: ${position.type.toUpperCase()} ${position.leverage}x\n`;
    positionsMessage += `‚Ä¢ Cantidad: ${position.amount} XLM\n`;
    positionsMessage += `‚Ä¢ Precio Entrada: $${position.entryPrice}\n`;
    positionsMessage += `‚Ä¢ PnL: ${pnlEmoji} ${pnl}\n`;
    positionsMessage += `‚Ä¢ Estado: ${position.status}\n\n`;
  });
  
  const keyboard = {
    reply_markup: {
      inline_keyboard: [
        [
          { text: 'üîÑ Actualizar', callback_data: 'refresh_positions' },
          { text: 'üìà Nueva Posici√≥n', callback_data: 'trading_menu' }
        ]
      ]
    }
  };
  
  bot.sendMessage(chatId, positionsMessage, { parse_mode: 'Markdown', ...keyboard });
});

// Comando /balance
bot.onText(/\/balance/, async (msg) => {
  const chatId = msg.chat.id;
  
  if (!userWallets.has(chatId)) {
    bot.sendMessage(chatId, '‚ùå Primero debes crear una wallet con /wallet');
    return;
  }
  
  try {
    const wallet = userWallets.get(chatId);
    const price = await getXlmPrice();
    
    // Simular balance (en producci√≥n, consultar la red Stellar)
    const xlmBalance = 1000.0; // Balance simulado
    const usdValue = xlmBalance * price;
    
    const balanceMessage = `
üí∞ **Balance de tu Wallet**

**XLM:** ${xlmBalance.toFixed(7)} XLM
**USD:** $${usdValue.toFixed(2)}
**Precio XLM:** $${price.toFixed(6)}

**Wallet:** \`${wallet.publicKey}\`

**√öltima actualizaci√≥n:** ${new Date().toLocaleString()}
    `;
    
    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üîÑ Actualizar', callback_data: 'refresh_balance' },
            { text: 'üìä Ver Precios', callback_data: 'view_prices' }
          ]
        ]
      }
    };
    
    bot.sendMessage(chatId, balanceMessage, { parse_mode: 'Markdown', ...keyboard });
    
  } catch (error) {
    bot.sendMessage(chatId, '‚ùå Error obteniendo balance. Intenta de nuevo.');
  }
});

// Comando /price
bot.onText(/\/price/, async (msg) => {
  const chatId = msg.chat.id;
  
  try {
    const price = await getXlmPrice();
    
    const priceMessage = `
üìä **Precio de XLM**

**Precio actual:** $${price.toFixed(6)} USD
**Red:** Stellar Testnet
**Actualizado:** ${new Date().toLocaleString()}

**Cambio 24h:** +2.5% üìà
**Volumen 24h:** $1.2M
    `;
    
    const keyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üîÑ Actualizar', callback_data: 'refresh_price' },
            { text: 'üí∞ Ver Balance', callback_data: 'view_balance' }
          ]
        ]
      }
    };
    
    bot.sendMessage(chatId, priceMessage, { parse_mode: 'Markdown', ...keyboard });
    
  } catch (error) {
    bot.sendMessage(chatId, '‚ùå Error obteniendo precio de XLM');
  }
});

// Manejar callbacks de botones
bot.on('callback_query', async (callbackQuery) => {
  const message = callbackQuery.message;
  const chatId = message.chat.id;
  const data = callbackQuery.data;
  
  try {
    await bot.answerCallbackQuery(callbackQuery.id);
    
    if (data === 'create_wallet') {
      const wallet = generateStellarWallet();
      const encryptedSecret = encrypt(wallet.secretKey);
      
      userWallets.set(chatId, {
        publicKey: wallet.publicKey,
        secretKey: encryptedSecret,
        createdAt: Date.now()
      });
      
      const walletMessage = `
üîë **Wallet Creada Exitosamente!**

**Clave P√∫blica:**
\`${wallet.publicKey}\`

**Clave Privada:**
\`${wallet.secretKey}\`

‚ö†Ô∏è **IMPORTANTE:** Guarda tu clave privada en un lugar seguro!

**Estado:** ‚úÖ Activa
**Red:** Stellar Testnet
**Fondeo:** Autom√°tico en testnet

**Pr√≥ximos pasos:**
‚Ä¢ Usa /balance para ver tu balance
‚Ä¢ Usa /swap para hacer tu primer swap
‚Ä¢ Usa /trade para abrir posiciones
      `;
      
      const keyboard = {
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üí∞ Ver Balance', callback_data: 'view_balance' },
              { text: 'üîÑ Hacer Swap', callback_data: 'make_swap' }
            ]
          ]
        }
      };
      
      await bot.editMessageText(walletMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        parse_mode: 'Markdown',
        ...keyboard
      });
      
    } else if (data === 'view_balance') {
      // Simular balance
      const balanceMessage = `
üí∞ **Balance de tu Wallet**

**XLM:** 1000.0000000 XLM
**USD:** $150.00
**Precio XLM:** $0.150000

**Wallet:** \`${userWallets.get(chatId)?.publicKey || 'N/A'}\`

**√öltima actualizaci√≥n:** ${new Date().toLocaleString()}
      `;
      
      await bot.editMessageText(balanceMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        parse_mode: 'Markdown'
      });
      
    } else if (data === 'view_prices') {
      const price = await getXlmPrice();
      const priceMessage = `
üìä **Precio de XLM**

**Precio actual:** $${price.toFixed(6)} USD
**Red:** Stellar Testnet
**Actualizado:** ${new Date().toLocaleString()}

**Cambio 24h:** +2.5% üìà
**Volumen 24h:** $1.2M
      `;
      
      await bot.editMessageText(priceMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        parse_mode: 'Markdown'
      });
      
    } else if (data === 'make_swap') {
      const swapMessage = `
üîÑ **Hacer Swap XLM ‚Üí USDC**

**Cantidad sugerida:** 10 XLM
**Destino:** USDC
**Red:** Stellar Testnet

**Usa el comando:**
\`/swap 10 XLM\`

**O elige una cantidad r√°pida:**
      `;
      
      const keyboard = {
        reply_markup: {
          inline_keyboard: [
            [
              { text: '5 XLM', callback_data: 'swap_5' },
              { text: '10 XLM', callback_data: 'swap_10' },
              { text: '50 XLM', callback_data: 'swap_50' }
            ],
            [
              { text: '100 XLM', callback_data: 'swap_100' },
              { text: 'Personalizar', callback_data: 'custom_swap' }
            ]
          ]
        }
      };
      
      await bot.editMessageText(swapMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        parse_mode: 'Markdown',
        ...keyboard
      });
      
    } else if (data.startsWith('swap_')) {
      const amount = data.replace('swap_', '');
      const swapMessage = `
üîÑ **Iniciando Swap de ${amount} XLM**

**Cantidad:** ${amount} XLM
**Destino:** USDC
**Estado:** Obteniendo cotizaci√≥n...

**Por favor espera...**
      `;
      
      await bot.editMessageText(swapMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        parse_mode: 'Markdown'
      });
      
      // Simular swap
      setTimeout(async () => {
        const successMessage = `
‚úÖ **Swap Exitoso!**

**Cantidad:** ${amount} XLM ‚Üí USDC
**Hash:** \`daa4df25...\`
**Ledger:** 12345678
**Red:** Stellar Testnet

**¬°Tu swap se ha completado exitosamente!** üéâ
        `;
        
        await bot.editMessageText(successMessage, {
          chat_id: chatId,
          message_id: message.message_id,
          parse_mode: 'Markdown'
        });
      }, 3000);
      
    } else if (data.startsWith('confirm_swap_')) {
      const amount = data.replace('confirm_swap_', '');
      
      const processingMessage = `
üöÄ **Ejecutando Swap...**

**Cantidad:** ${amount} XLM
**Estado:** Procesando transacci√≥n...

**Por favor espera...**
      `;
      
      await bot.editMessageText(processingMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        parse_mode: 'Markdown'
      });
      
      // Simular ejecuci√≥n
      setTimeout(async () => {
        const successMessage = `
‚úÖ **Swap Exitoso!**

**Cantidad:** ${amount} XLM ‚Üí USDC
**Hash:** \`daa4df25...\`
**Ledger:** 12345678
**Red:** Stellar Testnet

**¬°Tu swap se ha completado exitosamente!** üéâ
        `;
        
        await bot.editMessageText(successMessage, {
          chat_id: chatId,
          message_id: message.message_id,
          parse_mode: 'Markdown'
        });
      }, 3000);
      
    } else if (data.startsWith('trade_')) {
      const [_, type, leverage] = data.split('_');
      
      const tradeMessage = `
üìà **Abriendo Posici√≥n ${type.toUpperCase()} ${leverage}x**

**Cantidad:** 100 XLM
**Leverage:** ${leverage}x
**Tipo:** ${type.toUpperCase()}
**Estado:** Procesando...

**Por favor espera...**
      `;
      
      await bot.editMessageText(tradeMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        parse_mode: 'Markdown'
      });
      
      // Simular apertura de posici√≥n
      setTimeout(async () => {
        const positionId = Date.now().toString();
        const position = {
          id: positionId,
          type: type,
          leverage: parseInt(leverage),
          amount: 100,
          entryPrice: 0.15,
          pnl: 0,
          status: 'open'
        };
        
        if (!userPositions.has(chatId)) {
          userPositions.set(chatId, []);
        }
        userPositions.get(chatId).push(position);
        
        const successMessage = `
‚úÖ **Posici√≥n Abierta Exitosamente!**

**Tipo:** ${type.toUpperCase()} ${leverage}x
**Cantidad:** 100 XLM
**Precio Entrada:** $0.150000
**ID:** ${positionId}

**¬°Tu posici√≥n est√° activa!** üìà

Usa /positions para ver todas tus posiciones.
        `;
        
        await bot.editMessageText(successMessage, {
          chat_id: chatId,
          message_id: message.message_id,
          parse_mode: 'Markdown'
        });
      }, 3000);
      
    } else if (data === 'trading_menu') {
      const tradeMessage = `
üìà **Trading de Perpetuos**

**Configuraci√≥n de Posici√≥n:**
‚Ä¢ **Cantidad:** 100 XLM (por defecto)
‚Ä¢ **Leverage:** 2x (por defecto)
‚Ä¢ **Tipo:** Long (por defecto)

**¬øQuieres personalizar la configuraci√≥n?**
      `;
      
      const keyboard = {
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üìà Long 2x', callback_data: 'trade_long_2x' },
              { text: 'üìâ Short 2x', callback_data: 'trade_short_2x' }
            ],
            [
              { text: 'üìà Long 5x', callback_data: 'trade_long_5x' },
              { text: 'üìâ Short 5x', callback_data: 'trade_short_5x' }
            ],
            [
              { text: '‚öôÔ∏è Personalizar', callback_data: 'custom_trade' },
              { text: '‚ùå Cancelar', callback_data: 'cancel' }
            ]
          ]
        }
      };
      
      await bot.editMessageText(tradeMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        parse_mode: 'Markdown',
        ...keyboard
      });
      
    } else if (data === 'view_positions') {
      if (!userPositions.has(chatId) || userPositions.get(chatId).length === 0) {
        const noPositionsMessage = `
‚ùå **No tienes posiciones activas**

Usa /trade para abrir una nueva posici√≥n.
        `;
        
        await bot.editMessageText(noPositionsMessage, {
          chat_id: chatId,
          message_id: message.message_id,
          parse_mode: 'Markdown'
        });
        return;
      }
      
      const positions = userPositions.get(chatId);
      let positionsMessage = 'üìä **Tus Posiciones Activas**\n\n';
      
      positions.forEach((position, index) => {
        const pnl = position.pnl >= 0 ? `+$${position.pnl.toFixed(2)}` : `-$${Math.abs(position.pnl).toFixed(2)}`;
        const pnlEmoji = position.pnl >= 0 ? 'üìà' : 'üìâ';
        
        positionsMessage += `**Posici√≥n #${index + 1}:**\n`;
        positionsMessage += `‚Ä¢ Tipo: ${position.type.toUpperCase()} ${position.leverage}x\n`;
        positionsMessage += `‚Ä¢ Cantidad: ${position.amount} XLM\n`;
        positionsMessage += `‚Ä¢ Precio Entrada: $${position.entryPrice}\n`;
        positionsMessage += `‚Ä¢ PnL: ${pnlEmoji} ${pnl}\n`;
        positionsMessage += `‚Ä¢ Estado: ${position.status}\n\n`;
      });
      
      const keyboard = {
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üîÑ Actualizar', callback_data: 'refresh_positions' },
              { text: 'üìà Nueva Posici√≥n', callback_data: 'trading_menu' }
            ]
          ]
        }
      };
      
      await bot.editMessageText(positionsMessage, {
        chat_id: chatId,
        message_id: message.message_id,
        parse_mode: 'Markdown',
        ...keyboard
      });
      
    } else if (data === 'cancel') {
      await bot.editMessageText('‚ùå Operaci√≥n cancelada.', {
        chat_id: chatId,
        message_id: message.message_id
      });
    }
    
  } catch (error) {
    console.error('Error en callback:', error);
    await bot.editMessageText('‚ùå Ocurri√≥ un error. Intenta de nuevo.', {
      chat_id: chatId,
      message_id: message.message_id
    });
  }
});

// Manejo de errores
bot.on('error', (error) => {
  console.error('Error del bot:', error);
});

bot.on('polling_error', (error) => {
  console.error('Error de polling:', error);
});

console.log('ü§ñ Bot de Trading Completo iniciado...');
console.log('üì± Comandos disponibles: /start, /wallet, /swap, /trade, /positions, /balance, /price');
